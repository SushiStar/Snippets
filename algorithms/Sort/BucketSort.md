#Bucket Sort
Bucket sort assumes that input is drawn from a uniform distribution and has an average-case running time of $O(n)$. Whereas counting sort assumes that the input consists of integers in a small range, bucket sort assumes that the input is generated by a random process taht distributes elements uniformly and independently over the interval [0, 1).
Bucket sort divide the interval [0, 1) into $n$ equal-sized subintervals, or *buckets*, and then distributes the n input numbers into the buckets. To produce the output, we simply sort the numbers in each bucket and then go through the bucekts in order, listing the elements in each.

>BUCKET-SORT(A)
>1 	n = A.length
>2 	let B[0, ..., n-1] be a new array
>3 	for i = 0 to n-1
>		* make B[i] an empty list
>4 	for i = 0 to n-1
> 		* insert A[i] into list B[(int)n*A[i]]
>5 	for i = 0 to n-1
>		* sort list B[i] with insertion sort
>6 	concatenate the lists B[0], B[1], ..., B[n-1] together in order


**Time Complexity**: If we assume that insertion in a bucket takes O(1) time then steps 1 to 4 of the above algorithm clearly take O(n) time. The main step to analyze is step 5. This step also takes O(n) time on average if all numbers are uniformly distributed. This part is proven to be O(n) time. Ref: Intorduction to algorithms, page: 204.

```cpp
void bucketSort(float arr[], int n) {
	vector<float> buckets[n];
	for (int i = 0; i < n; ++i) {
		int bi = n*arr[i];
		buckets[bi].push_back(arr[i]);
	}
	for (int i = 0; i < n; ++i)
		sort(buckets[i].begin(), bucekts[i].end());
	int index = 0;
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < b[i].size(); ++j) {
			arr[index++] = b[i][j];
		}
	}
}
```
