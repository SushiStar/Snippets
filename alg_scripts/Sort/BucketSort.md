#Bucket Sort
Bucket sort assumes that input is drawn from a uniform distribution and has an average-case running time of $O(n)$. Whereas counting sort assumes that the input consists of integers in a small range, bucket sort assumes that the input is generated by a random process taht distributes elements uniformly and independently over the interval [0, 1).
Bucket sort divide the interval [0, 1) into $n$ equal-sized subintervals, or *buckets*, and then distributes the n input numbers into the buckets. To produce the output, we simply sort the numbers in each bucket and then go through the bucekts in order, listing the elements in each.

>Pseudocode
bucketSort(arr[], n)
1. Create n empty buckets (Or lists).
2. Do the following for every array element arr[i]:
	Insert arr[i] into bucket [n*array[i]]
3. Sort individual bucekts using *insertion sort*.
4. Concatenate all sorted buckets.

**Time Complexity**: If we assume that insertion in a bucket takes O(1) time then steps 1 and 2 of the above algorithm clearly take O(n) time. The main step to analyze is step 3. This step also takes O(n) time on average if all numbers are uniformly distributed.

```cpp
void bucketSort(float arr[], int n) {
	vector<float> buckets[n];
	for (int i = 0; i < n; ++i) {
		int bi = n*arr[i];
		buckets[bi].push_back(arr[i]);
	}
	for (int i = 0; i < n; ++i)
		sort(buckets[i].begin(), bucekts[i].end());
	int index = 0;
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < b[i].size(); ++j) {
			arr[index++] = b[i][j];
		}
	}
}
```
