# Chapter 12:Functions

## Function Declarations
- The semantics of argument passing are identical to the semantics of copy initialization.
    Argument types are checked and implicit argument type conversion takes place when necessary.
- The most basic advice is to keep a function of a size so that you can look at it in total on a screen.(40 lines on a function);
- virtual: indicating that it can be overridden in a derived class.
    override: indicating that it must be overriding a virtual function from a base class.
    static: inidicating that it is not associated with a particular object.
- A function called itself is said to be recursive.
- ***Each time a function is called, a new copy of its argument and local (automatic) variables is created. The store is reused after the function returns, so a pointer ot a local non-static variable should never be returned.***
- A function that does not return normally can be marked as <code>[[noreturn]]</code>
- A constexpr function consist of a single return-statement; no loops and no local variables are allowed.
- If a local variable is declared ***static***, a single, statically allocated object will be used to represent that variable in all calls of the function.

## Argument passing
- Declaring a pointer argument const tells readers that the value of an object pointed to by that argument is not changed by the function.
- Rules of passing arguments:
    * Use pass-by-value for small objects.
    * Use pass-by-const-reference to pass large values that you don't need to modify.
    * Return a result as a return value rather than modifying an object through an argument.
    * Use rvalue references to implement move and forwarding.
    * Pass a pointer if "no object" is a valid alternative.
    * Use pass-by-reference only if you have to.
## Overloaded Functions
- Overload resolution is independent of the order of declaration of the functions considered.
- Return types are not considered in overload resolution.
- Functions declared in different non-namespace scope do not overload.
## Pre- and Postconditions
The writer of a function has several alternatives, including:
* Make sure that every input has a valid result (so that we don't have a precondition).
* Assume that the precondition holds (rely on the caller not to make mistakes).
* Check that the precondition holds and throw an exception if it does not.
* Check that the precondition holds and terminate the program if it does not.
## Pointer to function
* Pointers to functions have argument types declared just like the functions themselves.
* There's no implicit conversions of argument or return type when pointers to functions are assigned or initialized.
## Macros
* The first rule about macros is: don't use them unless you have to.
* Macro names cannot be overloaded.
* The macro processor cannot handle recursive calls.



## constexpr

* 值不会改变并且在编译过程中就能得到结果的表达式。（运行中得到结果的不能成为常量表达式）

* c++11允许声明consexpr类型来由编译器检验变量的值是否为一个常量表达式。声明为constexpr的必须为一个常量，并且只能由常量或者常量表达式来初始化。

##When can I/should I use both, ```const ```and ```constexpr``` together?
* In object declarations. This is never necessary when both keywords refer to the same object to be declared.
  ```constexpr``` refers to  ````const```.
  ```
    constexpr const int N = 5;
  ```
  is the same as
  ```
    constexpr int N = 5;
  ```
 However, there may be situations when the keywords each refer to the different parts of the declaration:
 ```
    static constexpr int N = 3;
    int main() {
        constexpr const int* NP = &N;
    }
 ```
  Here, NP is declared as an address constant-expression, i.e. an pointer that is itself a constant expression.(This is possible when the address is generated by applying the address operator to a static/global constant expression.)
  Here, both constexpr and const are required: constexpr always refers to the expression being declared (here NP), while const refers to int (it declares a pointer-to-const).
  Removing the const would render the expression illegal (because (a) a pointer to a non-const object cannot be a constant expression, and (b) &N is in-fact a pointer-to-constant)
* In C++11, ```constexpr``` implies ```const```, while in C++14 and C++17 that is not the case. 
A member function declared under C++11 as 
```
    constexpr void f();
```
needs to be delclared as 
```
    constexpr void f() const;
```
under C++14 in order to be usable as a ```const``` function.
